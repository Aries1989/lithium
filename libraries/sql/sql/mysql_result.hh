#pragma once

#include <atomic>
#include <boost/lexical_cast.hpp>
#include <cassert>
#include <cstring>
#include <deque>
#include <iostream>
#include <map>
#include <memory>
#include <mutex>
#include <mysql.h>
#include <optional>
#include <sstream>
#include <sys/epoll.h>
#include <thread>
#include <unordered_map>

#include <li/callable_traits/callable_traits.hh>
#include <li/metamap/metamap.hh>
#include <li/sql/mysql_async_wrapper.hh>
#include <li/sql/mysql_statement.hh>
#include <li/sql/mysql_statement_result.hh>
#include <li/sql/sql_common.hh>
#include <li/sql/symbols.hh>
#include <li/sql/type_hashmap.hh>

namespace li {

/**
 * @brief Store a access to the result of a sql query (non prepared).
 *
 * @tparam B must be mysql_functions_blocking or mysql_functions_non_blocking
 */
template <typename B> struct mysql_result {

  B& mysql_wrapper_; // blocking or non blockin mysql functions wrapper.
  MYSQL* con_; // Mysql connection
  std::shared_ptr<int> connection_status_; // Status of the connection
  MYSQL_RES* result_ = nullptr; // Mysql result.


  /**
   * @return the number of rows affected by the request.
   */
  long long int affected_rows();

  /**
   * @brief access to the result of a single valued request (ex: select 1+2) and return the value.
   * Throw an exception if the request returned nothing.
   *
   * @return T the result value.
   */
  template <typename T> T read();

  /**
   * @brief acces to the result of single valued request (ex: select 1+2) and return a optinal value
   * wrapped with std::optional. the optional is empty if the request returned nothing.
   * @return std::optional<T> the result optional value.
   */
  template <typename T> std::optional<T> read_optional();

  /**
   * @brief Like read_optional but inplace.
   *
   * @tparam T
   * @param o the ouput optional value.
   */
  template <typename T> void read(std::optional<T>& o);

  /**
   * @brief Call a function on each result row.
   * The function must take as argument all the select fields of the request.
   *
   * @example connection.prepare("Select id,post from post_items;")().map(
   *        [&](std::string id, std::string post) {
   *             std::cout << id << post << std::endl; });
   *
   * @param f the function.
   */
  template <typename F> void map(F f);

  /**
   * @brief Return the last id generated by a insert comment.
   *
   * @return the last inserted id.
   */
  long long int last_insert_id();

  /**
   * @return Return true if the statement returned no row.
   */
  bool empty();

  // Internal.
  void wait() {};
};

} // namespace li

#include <li/sql/mysql_result.hpp>
